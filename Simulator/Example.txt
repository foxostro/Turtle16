# let kSerialInterface = 6
# let kIORegister = 0
# let kStatusRegister = 1


# Increment the A register and count up from 0 to 42.
LI A, 0
countUpLoop:
LI B, 1
ADD A
LI B, 42
CMP
LXY countUpLoop
JNE
NOP
NOP


# First, setup a string in data RAM at address 100.
LXY setupStringInMemory
LINK
JMP
NOP
NOP

# Second, setup the address registers to prepare for the copy.
LI D, 6 # kSerialInterface
LI X, 0
LI Y, 0 # kIORegister
LI U, 0
LI V, 100

MOV P, M
INUV
MOV P, M
INUV
MOV P, M
INUV
MOV P, M
INUV
MOV P, M
INUV
MOV P, M
INUV
MOV P, M
INUV
MOV P, M
INUV
MOV P, M
INUV
MOV P, M
INUV
MOV P, M
INUV
MOV P, M
INUV
MOV P, M
INUV
MOV P, M
INUV



# Now, we enter a loop where we wait for serial input and then echo it to
# serial output.

beginningOfInputLoop:

LXY waitForInput
LINK
JMP
NOP
NOP

# Read a byte and echo it back.
LI D, 6 # kSerialInterface
LI Y, 0 # kIORegister
MOV A, P
NOP
MOV P, A
NOP

LXY beginningOfInputLoop
JMP
NOP
NOP
HLT



# This is a function to copy a string from instruction memory to data RAM at
# address 100.
setupStringInMemory:
LI U, 0
LI V, 100
LI M, 'H'
INUV
LI M, 'e'
INUV
LI M, 'l'
INUV
LI M, 'l'
INUV
LI M, 'o'
INUV
LI M, ','
INUV
LI M, ' '
INUV
LI M, 'W'
INUV
LI M, 'o'
INUV
LI M, 'r'
INUV
LI M, 'l'
INUV
LI M, 'd'
INUV
LI M, '!'
INUV
LI M, 10
MOV X, G
MOV Y, H
JMP
NOP
NOP




# This is a function which waits until the number of available bytes is greater
# than zero and then returns to caller.
# The return address is stored in the Link register upon entering the function.
waitForInput:
LI D, 6 # kSerialInterface
LI Y, 1 # kStatusRegister
MOV B, P
LI A, 1
CMP
LXY waitForInput
JC
NOP
NOP

# Return from the function.
MOV X, G
MOV Y, H
JMP
NOP
NOP
